/*
	Copyright 2025-9999 sub1to

	This file is part of mkproj

	mkproj is free software; See LICENSE.MD or https://opensource.org/license/mit
*/

#include "pch.h"
#include "mkproj.h"

#include <iostream>
#include <fstream>
#include <filesystem>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <span>
#include <string_view>
#include <random>
#include <cstdint>

namespace mkproj
{

static const char* PREMAKE_LUA = R"lua(
-- Generated by mkproj
local PROJECT_DIR          = path.getabsolute(".")
local PROJECT_BUILD_DIR    = path.join(PROJECT_DIR, ".build/")
local PROJECT_PROJECTS_DIR = path.join(PROJECT_DIR, ".projects")
local PROJECT_RUNTIME_DIR  = path.join(PROJECT_DIR, ".bin/")

workspace "[[PROJECT_NAME]]"
    language                "C++"
    configurations          { "Debug", "Release", "Dev" }
    platforms               { "x64" }
    
    location                (path.join(PROJECT_PROJECTS_DIR, _ACTION))
    objdir                  (path.join(PROJECT_BUILD_DIR, _ACTION))
    
    filter "configurations:Debug"
        targetdir(path.join(PROJECT_RUNTIME_DIR, "debug/"))
        
    filter "configurations:Dev"
        targetdir(path.join(PROJECT_RUNTIME_DIR, "dev/"))
        
    filter "configurations:Release"
        targetdir(path.join(PROJECT_RUNTIME_DIR, "release/"))
        
    -- Set the toolset according to the action
    filter "action:vs*"
        toolset "msc"
    filter "action:gmake*"
        toolset "gcc"
    filter {}
    
    include "[[PROJECT_NAME]]/[[PROJECT_NAME]].lua"
    
    -- Externals

)lua";



static const char* PROJECT_LUA = R"lua(
-- Generated by mkproj
project "[[PROJECT_NAME]]"
    uuid                "[[PROJECT_UUID]]"
    kind                "[[PROJECT_KIND]]"
    characterset        "Unicode"
    targetname          "[[PROJECT_NAME]]"
    language            "C++"
    cppdialect          "C++20" 
    pchheader           "pch.h"
    pchsource           "src/pch.cpp"
    
    files
    {
        "include/**.hpp",
        "include/**.h",
        
        "src/**.inc",
        "src/**.asm",
        "src/**.cpp",
        "src/**.hpp",
        "src/**.h",
    }   
    
    vpaths {
        ["src/*"]     = "src/**",
        ["include/*"] = "include/**"
    }
    
    includedirs {
        "include",
        "src",
    }
    
    libdirs {
        "lib/",
    }
    
    links {
        
    }
    
    linkoptions {
        
    }
    
    defines {
        
    }

[[PEDANTIC_1]]
    filter "configurations:Debug"
        defines { "DEBUG" }
        optimize "Off"
        symbols "On"
        linktimeoptimization "Off"
        editandcontinue "Off"
        sanitize { "Address" }
        
    filter "configurations:Dev"
        flags { "NoIncrementalLink" }
        optimize "Off"
        symbols "Off"
        linktimeoptimization "On"
        
    filter "configurations:Release"
        flags { "NoIncrementalLink" }
        defines { "NDEBUG" }
        optimize "Full"
        symbols "Off"
        linktimeoptimization "On"
        
    filter { "configurations:Release", "toolset:gcc or clang" }
        buildoptions {
            "-flto=auto"
        }
        
        linkoptions {
            "-flto=auto"
        }
        
[[PEDANTIC_2]]
    filter {}
)lua";



static const char* PROJECT_LUA_PEDANTIC_1 = R"lua(
    warnings "Extra"        -- msc: /W4; gcc: -Wall -Wextra
    fatalwarnings "All"     -- msc: /WX; gcc: -Werror
    conformancemode "On"    -- msc: /permissive-
)lua";



static const char* PROJECT_LUA_PEDANTIC_2 = R"lua(
    -- Linux hardening
    filter "toolset:gcc or clang"
        buildoptions {
            "-Wpedantic",                   -- Warn on non-standard C++ extensions
            "-Wshadow",                     -- Even more pedantic
            "-Wconversion",                 -- Even more pedantic!!
            "-fstack-clash-protection",     -- chkstk probe
            "-fstack-protector-strong",     -- stack cookies
            "-fPIE"                         -- ASLR
        }
        
        linkoptions {
            "-pie",         -- ASLR
            "-Wl,-z,relro", -- .reloc readonly
            "-Wl,-z,now"    -- resolve GOT and PLT at init (like IAT in PE32+)
        }
    
    
    -- Windows "hardening"
    filter "toolset:msc"
        buildoptions {
            "/permissive-", -- Strict C++ standard, no MSVC bullshit
            "/w14242",      -- Warn on conversion checks
            "/w14254",      -- Warn on operator conversion
        }
)lua";



static const char* SOURCE_MAIN_CPP = R"cpp(
#include "pch.h"

)cpp";



static const char* SOURCE_PCH_CPP = R"cpp(
#include "pch.h"

)cpp";



static const char* SOURCE_PCH_H = R"cpp(
#ifndef PCH_H
#define PCH_H



#endif //PCH_H
)cpp";



static const char* BUILD_VS2022 = R"bash(
#!/bin/bash

premake5.exe vs2022
)bash";



static const char* BUILD_GMAKE = R"bash(
#!/bin/bash

premake5 gmake
)bash";



static const char* CLEAN_BASH = R"bash(
#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

if [ -z "$SCRIPT_DIR" ]; then
    echo "Error: Could not determine script directory."
    exit 1
fi

cd "$SCRIPT_DIR" || { echo "Failed to enter $SCRIPT_DIR"; exit 1; }

if [ ! -f "$SCRIPT_DIR/premake5.lua" ]; then
    echo "Error: Safety check failed."
    echo "premake5.lua not found in $SCRIPT_DIR"
    echo "Aborting clean to prevent accidental deletion."
    exit 1
fi

rm -rf "$SCRIPT_DIR/.build" "$SCRIPT_DIR/.projects"
echo "Cleaned build artifacts in $SCRIPT_DIR"
)bash";

static const char* MAKEFILE = R"make(
BUILD_DIR := .projects/gmake

.PHONY: %
%:
	@$(MAKE) --no-print-directory -C $(BUILD_DIR) $@

all:
	@$(MAKE) --no-print-directory -C $(BUILD_DIR)
)make";



static const char* GITIGNORE = R"txt(
.bin/
.build/
.projects/
)txt";



static const char* GITATTRIBUTES = R"txt(
# Default behavior: auto-detect text, force LF
* text=auto eol=lf

# Explicitly force C++ files to be text (safeguard)
*.cpp text eol=lf
*.hpp text eol=lf
*.h   text eol=lf
)txt";



static const char* EDITORCONFIG = R"txt(
[*.{c,h,cpp,hpp}]
indent_style = space
indent_size = 4
end_of_line = lf
)txt";



bool write_file(const std::filesystem::path& path, const std::string_view data)
{
    std::ofstream ofs(path, std::ios_base::trunc); 

    if(!ofs){
        return false;
    }

    ofs << data;

    ofs.flush();

    return ofs.good();
}

void    replace_placeholder(std::string& source, const std::string_view tag, const std::string_view replacement)
{
    size_t  pos;

    if(tag.empty()){
        return;
    }

    pos     = 0;

    for(;;){
        pos     = source.find(tag, pos);

        if(pos == std::string::npos){
            break;
        }

        source.replace(pos, tag.size(), replacement);

        pos     += replacement.size();
    }
}

bool    create_dir(const std::string_view dir)
{
    std::error_code err;
    std::cout << "Creating directory: " << dir << std::endl;
    std::filesystem::create_directory(dir, err);
    return err == std::errc{};
}

bool    create_file(const std::string_view file, const std::string_view value)
{
    std::cout << "Creating file:      " << file << std::endl;
    return write_file(file, value);
}

std::string_view generate_random_uuid(std::span<char> buf)
{
    using prng_gen      = std::mt19937_64; // Mersenne Twister
    using uniform_dist  = std::uniform_int_distribution<uint64_t>;

    static constexpr char               HEX_CHARS[] = "0123456789abcdef";

    static thread_local prng_gen        s_gen(std::random_device{}());
    static thread_local uniform_dist    s_dist(0, 0xFFFFFFFFFFFFFFFF);

    uint64_t    blocks[2];  // 16 bytes of entropy
    uint8_t*    bytes;
    size_t      i;

    // nbytes * chars_per_byte + ndashes + zeroterm
    if(buf.size() < 37){
        return {}; 
    }

    for(auto& block : blocks){
        block   = s_dist(s_gen);
    }

    i           = 0;
    bytes       = reinterpret_cast<uint8_t*>(blocks);
    bytes[6]    = (bytes[6] & 0x0F) | 0x40; // Version 4
    bytes[8]    = (bytes[8] & 0x3F) | 0x80; // Variant 1

    auto write_n_hex = [&](size_t n, size_t start){
        for(size_t j = 0; j < n; ++j){
            uint8_t byte = bytes[start + j];
            buf[i++] = HEX_CHARS[(byte >> 4) & 0xF];
            buf[i++] = HEX_CHARS[byte & 0xF];
        }
    };

    write_n_hex(4, 0);
    buf[i++] = '-';

    write_n_hex(2, 4);
    buf[i++] = '-';

    write_n_hex(2, 6);
    buf[i++] = '-';

    write_n_hex(2, 8);
    buf[i++] = '-';

    write_n_hex(6, 10);
    buf[i] = '\0';

    return {buf.data(), i};
}

bool    can_create_project(const std::string& workspaceName)
{
    std::error_code err;

    if(std::filesystem::exists(workspaceName, err)){
        std::cerr << "Directory " << workspaceName << " already exists. aborting." << std::endl;
        return false;
    }

    if(err != std::errc{}){
        std::cerr << "Error checking if directory " << workspaceName << " exists. aborting." << std::endl;
        return false;
    }

    return true;
}

bool    create_project(const std::string& workspaceName, const std::string& projectName, const std::string& projectKind, const bool pedantic)
{
    std::string         pathProjRoot;
    bool                isLib;
    bool                success;
    char                uuidBuf[40];

    pathProjRoot    = workspaceName + "/" + projectName;
    isLib           = projectKind == "SharedLib" || projectKind == "StaticLib";

    success = true
    && create_dir(workspaceName)
    && create_dir(pathProjRoot)
    && create_dir(pathProjRoot + "/src")
    && create_dir(pathProjRoot + "/lib")
    && (!isLib || create_dir(pathProjRoot + "/include"))
    ;

    if(!success){
        return false;
    }

    // +1 to skip the first LF
    success = true
    && create_file(pathProjRoot + "/src/main.cpp",      SOURCE_MAIN_CPP + 1)
    && create_file(pathProjRoot + "/src/pch.cpp",       SOURCE_PCH_CPP + 1)
    && create_file(pathProjRoot + "/src/pch.h",         SOURCE_PCH_H + 1)
    && create_file(workspaceName + "/build_vs2022.sh",  BUILD_VS2022 + 1)
    && create_file(workspaceName + "/build_gmake.sh",   BUILD_GMAKE + 1)
    && create_file(workspaceName + "/clean.sh",         CLEAN_BASH + 1)
    && create_file(workspaceName + "/Makefile",         MAKEFILE + 1)
    && create_file(workspaceName + "/.gitignore",       GITIGNORE + 1)
    && create_file(workspaceName + "/.gitattributes",   GITATTRIBUTES + 1)
    && create_file(workspaceName + "/.editorconfig",    EDITORCONFIG + 1)
    ;

    if(!success){
        return false;
    }

    // + 1 skip the first LF
    std::string         premake5Lua         = PREMAKE_LUA + 1;
    std::string         projectLua          = PROJECT_LUA + 1;
    std::string_view    projectPedantic1Lua = PROJECT_LUA_PEDANTIC_1 + 1;
    std::string_view    projectPedantic2Lua = PROJECT_LUA_PEDANTIC_2 + 1;
    std::string_view    projectUUID         = generate_random_uuid(uuidBuf);

    if(projectUUID.empty()){
        return false;
    }

    replace_placeholder(premake5Lua, "[[PROJECT_NAME]]", projectName);
    replace_placeholder(projectLua,  "[[PROJECT_NAME]]", projectName);
    replace_placeholder(projectLua,  "[[PROJECT_KIND]]", projectKind);
    replace_placeholder(projectLua,  "[[PROJECT_UUID]]", projectUUID);

    if(pedantic){
        replace_placeholder(projectLua, "[[PEDANTIC_1]]", projectPedantic1Lua);
        replace_placeholder(projectLua, "[[PEDANTIC_2]]", projectPedantic2Lua);
    } else {
        replace_placeholder(projectLua, "[[PEDANTIC_1]]", "");
        replace_placeholder(projectLua, "[[PEDANTIC_2]]", "");
    }

    success = true
    && create_file(workspaceName + "/premake5.lua",          premake5Lua)
    && create_file(pathProjRoot + "/" + projectName +".lua", projectLua)
    ;

    return success;
}




} // namespace mkproj
